class t{#t=new Map;get(t,e){return this.#t.get(t)?.get(e)}set(t,e,s){let r=this.#t.get(t);return r||(r=new Map,this.#t.set(t,r)),r.set(e,s),this}setGet(t,e,s){return this.set(t,e,s),s}}class e{static makeSuccess(t,e){return{status:!0,value:e,position:t}}static makeFailure(t){return{status:!1,value:null,position:t}}static makeContext(e=null,s=""){return{regexer:e,input:s,equals:new t,visited:new Map}}}class s{static TerminalType={STARTING:-1,ONLY:0,ENDING:1};static isTerminal=!1;static indentation="    ";#e;#s={};predicate=t=>this===t||t instanceof Function&&this instanceof t;isActualParser=!0;Self;static mergeResults(t,e){return e?{status:t.status,position:t.position,value:t.value}:t}constructor(){this.Self=this.constructor}matchesEmpty(){return void 0===this.#e?this.#e=this.doMatchesEmpty():this.#e}doMatchesEmpty(){const t=this.unwrap();return 1===t.length&&t[0].doMatchesEmpty()}terminalList(t,s=[],r=e.makeContext(null,"")){if(r.visited.has(this))return[];if(this.#s[t]&&0===s.length)return this.#s[t];r.visited.set(this,null),this.#s[t]=this.doTerminalList(t,s,r);let i=this.#s[t];return s.length&&(this.#s[t]=this.#s[t].filter((t=>t.constructor.isTerminal||!s.includes(t)))),!this.constructor.isTerminal&&s.includes(this)&&(i=[this,...i]),i}doTerminalList(t,e,s){let r=this.unwrap();return 1===r?.length?r[0].terminalList(t,e,s):[]}dominates(t){}unwrap(t=null){return[]}wrap(...t){return null}parse(t,e){return null}actualParser(t=[],e=[],s=null){let r=(!this.isActualParser||t.some(this.predicate))&&!e.some(this.predicate),i=r?this.unwrap(s):void 0;return r&&=1===i?.length,r?i[0].actualParser(t,e,s):this}withActualParser(t,e=[],s=[],r=null){let i=(!this.isActualParser||e.some(this.predicate))&&!s.some(this.predicate),a=i?this.unwrap(r):void 0;return i&&=1===a?.length,i?this.wrap(a[0].withActualParser(t,e,s,r)):t}equals(t,e,s){let r=this;if(r===e)return!0;if(s||(r=this.actualParser(),e=e.actualParser()),e instanceof r.constructor&&!(r instanceof e.constructor)||e.resolve&&!r.resolve){const t=r;r=e,e=t}let i=t.equals.get(r,e);return void 0!==i||void 0===i&&(t.equals.set(r,e,!0),i=r.doEquals(t,e,s),t.equals.set(r,e,i)),i}doEquals(t,e,s){return!1}toString(t=e.makeContext(null,""),s=0){return t.visited.has(this)?"<...>":(t.visited.set(this,null),this.doToString(t,s))}doToString(t,e=0){return`${this.constructor.name} does not implement toString()`}}class r extends s{static isTerminal=!0;static successParserInstance;#r;get value(){return this.#r}constructor(t){super(),this.#r=t}doMatchesEmpty(){return""===this.#r}doTerminalList(t,e,s){return""===this.value?[r.successParserInstance]:[this]}dominates(t){if((t=t.actualParser())instanceof r){return t.#r.startsWith(this.#r)}}parse(t,s){const r=s+this.#r.length,i=t.input.substring(s,r);return this.#r===i?e.makeSuccess(r,this.#r):e.makeFailure(s)}doEquals(t,e,s){return e instanceof r&&this.#r===e.#r}doToString(t,e=0){const s=this.value.replaceAll("\n","\\n");return 1!==this.value.length||this.value.trim()!==this.value?`"${s.replaceAll('"','\\"')}"`:s}}class i extends r{static instance=new i;static{r.successParserInstance=this.instance}constructor(){super("")}doEquals(t,e,s){return s?e instanceof i:super.doEquals(t,e,!1)}doToString(t,e=0){return"<SUCCESS>"}}class a extends s{#i=!1;get backtracking(){return this.#i}#a;get parsers(){return this.#a}constructor(...t){super(),this.#a=t,1===this.#a.length&&(this.isActualParser=!1)}doMatchesEmpty(){return this.#a.some((t=>t.matchesEmpty()))}doTerminalList(t,s,r){return this.#a.flatMap((e=>e.terminalList(t,s,r))).reduce(((t,s)=>(t.some((t=>t.equals(e.makeContext(),s,!0)))||t.push(s),t)),[])}unwrap(t=null){if(t){const e=this.#a.find((e=>e.terminalList(s.TerminalType.ONLY,[t]).includes(t)));if(e)return[e]}return[...this.#a]}wrap(...t){const e=new this.Self(...t);return e.#i=this.#i,e}withActualParser(t,e=[],s=[],r=null){if(null!==t||null===r)return super.withActualParser(t,e,s,r);if(!((!this.isActualParser||e.some(this.predicate))&&!s.some(this.predicate)))return t;const i=this.unwrap(r)?.[0];if(!i)return t;const a=this.#a.indexOf(i),n=[...this.#a];return n.splice(a,1),this.wrap(...n)}asBacktracking(){const t=this.wrap(...this.#a);return t.#i=!0,t}parse(t,s){let r;for(let e=0;e<this.#a.length;++e)if(r=this.#a[e].parse(t,s),r.status)return r;return e.makeFailure(s)}doEquals(t,e,s){if(!(e instanceof a)||this.#a.length!=e.#a.length||this.#i!==e.#i)return!1;for(let r=0;r<this.#a.length;++r)if(!this.#a[r].equals(t,e.#a[r],s))return!1;return!0}doToString(t,e=0){const a=s.indentation.repeat(e),n=s.indentation.repeat(e+1);if(2===this.#a.length&&this.#a[1]instanceof i){let s=this.#a[0].toString(t,e);return this.#a[0]instanceof r||t.visited.has(this.#a[0])||(s="<"+s+">"),s+="?",s}return"ALT<\n"+n+this.#a.map((s=>s.toString(t,e+1))).join("\n"+n+"| ")+"\n"+a+">"}}class n extends s{#n;get parser(){return this.#n}#u;constructor(t,e){super(),this.#n=t,this.#u=e}doMatchesEmpty(){return!1}unwrap(t=null){return[this.#n]}wrap(...t){return new n(t[0],this.#u)}parse(t,s){let r=this.#n.parse(t,s);return r.status?(r=this.#u(r.value,t.input,r.position)?.getParser().parse(t,r.position)??e.makeFailure(r.position),r):r}doEquals(t,e,s){return e instanceof n&&this.#u===e.#u&&this.#n.equals(t,e.parser,s)}doToString(t,e=0){return this.#n.toString(t,e)+" => chained<f()>"}}class u extends s{static isTerminal=!0;static instance=new u;doTerminalList(t,e,s){return[this]}parse(t,s){return e.makeFailure(s)}doEquals(t,e,s){return e instanceof u}doToString(t,e=0){return"<FAILURE>"}}class p extends s{#n;isActualParser=!1;#p;constructor(t){super(),this.#n=t}resolve(){return this.#p||(this.#p=this.#n().getParser()),this.#p}unwrap(t=null){return[this.resolve()]}wrap(...t){const e=this.#n().constructor;return new p((()=>new e(t[0])))}parse(t,e){return this.resolve(),this.#p.parse(t,e)}doEquals(t,e,s){if(e instanceof p){if(this.#n===e.#n)return!0;e=e.resolve()}else if(s)return!1;return this.resolve(),this.#p.equals(t,e,s)}doToString(t,e=0){return this.resolve().toString(t,e)}}class h extends s{#n;get parser(){return this.#n}#h;get type(){return this.#h}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(t,e){super(),this.#n=t,this.#h=e}doTerminalList(t,e,s){return[]}unwrap(t=null){return[this.#n]}wrap(...t){return new h(t[0],this.#h)}parse(t,s){if(this.#h===h.Type.NEGATIVE_BEHIND||this.#h===h.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#n.parse(t,s).status==(this.#h===h.Type.POSITIVE_AHEAD)?e.makeSuccess(s,""):e.makeFailure(s)}doEquals(t,e,s){return this===e||e instanceof h&&this.#h===e.#h&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){return"("+this.#h+this.#n.toString(t,e)+")"}}class c extends s{#n;get parser(){return this.#n}#c;get mapper(){return this.#c}isActualParser=!1;constructor(t,e){super(),this.#n=t,this.#c=e}unwrap(t=null){return[this.#n]}wrap(...t){return new c(t[0],this.#c)}parse(t,e){const s=this.#n.parse(t,e);return s.status&&(s.value=this.#c(s.value)),s}doEquals(t,e,s){return e instanceof c&&this.#c===e.#c&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){let s=this.#c.toString();return(s.length>80||s.includes("\n"))&&(s="( ... ) => { ... }"),this.#n.toString(t,e)+` -> map<${s}>`}}class l extends s{static isTerminal=!0;#l;get regexp(){return this.#l}#o;#m;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(t,e){super(),t instanceof RegExp?(this.#l=t,this.#o=new RegExp(`^(?:${t.source})`,t.flags)):t instanceof l&&(this.#l=t.#l,this.#o=t.#o,this.regexpGenerated=t.regexpGenerated,this.regexpFullyGenerated=t.regexpFullyGenerated,this.cyclomaticComplexity=t.cyclomaticComplexity),this.#m=e}doTerminalList(t,e,s){return[this]}isFullyGenerated(){return this.regexpFullyGenerated}parse(t,s){const r=this.#o.exec(t.input.substring(s));return r?e.makeSuccess(s+r[0].length,this.#m>=0?r[this.#m]:r):e.makeFailure(s)}doEquals(t,e,s){return e instanceof l&&(!s||this.#m===e.#m)&&this.#l.source===e.#l.source}doToString(t,e=0){return"/"+this.#l.source+"/"}}class o extends s{#a;get parsers(){return this.#a}constructor(...t){super(),this.#a=t,1===this.#a.length&&(this.isActualParser=!1)}doTerminalList(t,e,r){if(0===t){for(let s=0;s<this.#a.length;++s)if(!this.#a[s].matchesEmpty())for(let i=this.#a.length-1;i>=s;--i)if(!this.#a[i].matchesEmpty())return s==i?this.#a[s].terminalList(t,e,r):[];t=s.TerminalType.STARTING}let a=t<0?0:this.#a.length-1;const n=-t,u=this.#a[a].terminalList(t,e,r);for(a+=n;a>=0&&a<this.#a.length&&this.#a[a-n].matchesEmpty();a+=n)this.#a[a].terminalList(t,e,r).reduce(((t,e)=>(t.some((t=>t.equals(r,e,!1)))||t.push(e),t)),u);if(!this.#a[a-n].matchesEmpty()){const t=u.indexOf(i.instance);t>=0&&u.splice(t,1)}return u}doMatchesEmpty(){return this.#a.every((t=>t.matchesEmpty()))}unwrap(t=null){return[...this.#a]}wrap(...t){return new o(...t)}parse(t,s){const r=new Array(this.#a.length),i=e.makeSuccess(s,r);for(let e=0;e<this.#a.length;++e){const s=this.#a[e].parse(t,i.position);if(!s.status)return s;i.value[e]=s.value,i.position=s.position}return i}doEquals(t,e,s){if(!(e instanceof o)||this.#a.length!=e.#a.length)return!1;for(let r=0;r<this.#a.length;++r)if(!this.#a[r].equals(t,e.#a[r],s))return!1;return!0}doToString(t,e=0){const r=s.indentation.repeat(e),i=s.indentation.repeat(e+1);return"SEQ<\n"+this.#a.map((s=>i+s.toString(t,e+1))).join("\n")+"\n"+r+">"}}class m extends s{#i=!1;get backtracking(){return this.#i}#n;get parser(){return this.#n}#g;get min(){return this.#g}#d;get max(){return this.#d}constructor(t,e=0,s=Number.POSITIVE_INFINITY){if(super(),e>s)throw new Error("Min is greater than max");this.#n=t,this.#g=e,this.#d=s}doMatchesEmpty(){return 0===this.#g}doTerminalList(t,e,s){const r=this.#n.terminalList(t,e,s);return this.matchesEmpty()&&!r.some((t=>i.instance.equals(s,t,!1)))&&r.push(i.instance),r}unwrap(t=null){return[this.#n]}wrap(...t){const e=new m(t[0],this.#g,this.#d);return this.#i&&(e.#i=!0),e}asBacktracking(){const t=new m(this.#n,this.#g,this.#d);return t.#i=!0,t}parse(t,s){const r=e.makeSuccess(s,[]);for(let e=0;e<this.#d;++e){const s=this.#n.parse(t,r.position);if(!s.status)return e>=this.#g?r:s;r.value.push(s.value),r.position=s.position}return r}doEquals(t,e,s){return e instanceof m&&this.#i===e.#i&&this.#g===e.#g&&this.#d===e.#d&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){return this.parser.toString(t,e)+(0===this.#g&&1===this.#d?"?":0===this.#g&&this.#d===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#d===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#d?",":this.#d!==Number.POSITIVE_INFINITY?this.#d:"")+"}")}}class g extends a{constructor(t){super(t,i.instance)}unwrap(t=null){return[this.parsers[0]]}wrap(...t){return super.wrap(...t,i.instance)}}class d{#n;#f;#w=new Map;Self;static#x=t=>Number(t);static#E=([t,e])=>t;static#S=([t,e])=>e;static#T=([t,e])=>[t,...e];static#k=t=>t instanceof Array?t.join(""):t;static#y=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static#v=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#v.source+String.raw`(?!\.)`)).map(this.#x);static numberNatural=this.regexp(/\d+/).map(this.#x);static numberExponential=this.regexp(new RegExp(this.#v.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#x);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#x);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#y('"')})"`)).map(this.#S);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#y("'")})'`)).map(this.#S);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#y("`")})\``)).map(this.#S);constructor(t,e=!1){this.Self=this.constructor,this.#n=t,this.#f=e}static optimize(t){}static equals(t,s,r=!1){const i=t instanceof d?t.getParser():t,a=s instanceof d?s.getParser():s;return i.equals(e.makeContext(t instanceof d?t:s instanceof d?s:null),a,r)}getParser(){return this.#n}run(t){const s=this.#n.parse(e.makeContext(this,t),0);return s.status&&s.position===t.length?s:e.makeFailure(s.position)}parse(t){const e=this.run(t);if(!e.status)throw new Error("Parsing error");return e.value}static str(t){return new this(new r(t))}static regexp(t,e=0){return new this(new l(t,e))}static regexpGroups(t){return new this(new l(t,-1))}static success(){return new this(i.instance)}static failure(){return new this(u.instance)}static seq(...t){return new this(new o(...t.map((t=>t.getParser()))))}static alt(...t){return new this(new a(...t.map((t=>t.getParser()))))}static lookahead(t){return new this(new h(t.getParser(),h.Type.POSITIVE_AHEAD))}static lazy(t){return new this(new p(t))}times(t,e=t){return new this.Self(new m(this.#n,t,e))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(t){return this.times(t,Number.POSITIVE_INFINITY)}atMost(t){return this.times(0,t)}opt(){return new this.Self(new g(this.#n))}sepBy(t,e=!1){return this.Self.seq(this,this.Self.seq(t,this).map(d.#S).many()).map(d.#T)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(d.#E)}map(t){return new this.Self(new c(this.#n,t))}chain(t){return new this.Self(new n(this.#n,t))}assert(t){return this.chain(((e,s,r)=>t(e,s,r)?this.Self.success().map((()=>e)):this.Self.failure()))}join(t=""){return this.map(d.#k)}toString(t=0,r=!1){return(r?"\n"+s.indentation.repeat(t):"")+this.#n.toString(e.makeContext(this,""),t)}}export{d as default};
