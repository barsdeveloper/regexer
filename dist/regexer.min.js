class t{#t=new Map;get(t,e){return this.#t.get(t)?.get(e)}set(t,e,r){let s=this.#t.get(t);return s||(s=new Map,this.#t.set(t,s)),s.set(e,r),this}setGet(t,e,r){return this.set(t,e,r),r}}class e{static makeSuccess(t,e){return{status:!0,value:e,position:t}}static makeFailure(t){return{status:!1,value:null,position:t}}static makeContext(e,r=""){return{regexer:e,input:r,equals:new t,visited:new Set}}}class r{static isTerminal=!1;static indentation="    ";#e;#r;isActualParser=!0;static mergeResults(t,e){return e?{status:t.status,position:t.position,value:t.value}:t}matchesEmpty(){return void 0===this.#e?this.#e=this.doMatchesEmpty():this.#e}doMatchesEmpty(){const t=this.unwrap();return 1===t.length&&t[0].doMatchesEmpty()}starterList(t=e.makeContext(null,""),r=[]){this.#r||t.visited.has(this)||(t.visited.add(this),this.#r=this.doStarterList(t,r),r.length&&(this.#r=this.#r.filter((t=>!t.constructor.isTerminal&&r.includes(t)))));let s=this.#r;return!this.constructor.isTerminal&&r.includes(this)&&(s=[this,...s]),s}doStarterList(t,e=[]){let r=this.unwrap();return 1===r?.length?r[0].starterList(t,e):[]}dominates(t){}unwrap(){return[]}wrap(...t){return null}parse(t,e){return null}actualParser(t=[],e=[]){let r=(!this.isActualParser||t.find((t=>this instanceof t)))&&!e.find((t=>this instanceof t)),s=r?this.unwrap():void 0;return r&&=1===s?.length,r?s[0].actualParser(t,e):this}withActualParser(t,e=[],r=[]){let s=(!this.isActualParser||e.some((t=>this instanceof t)))&&!r.some((t=>this instanceof t)),a=s?this.unwrap():void 0;return s&&=1===a?.length,s?this.wrap(a[0].withActualParser(t,e,r)):t}equals(t,e,r){let s=this;if(s===e)return!0;if(r||(s=this.actualParser(),e=e.actualParser()),e instanceof s.constructor&&!(s instanceof e.constructor)||e.resolve&&!s.resolve){const t=s;s=e,e=t}let a=t.equals.get(s,e);return void 0!==a||void 0===a&&(t.equals.set(s,e,!0),a=s.doEquals(t,e,r),t.equals.set(s,e,a)),a}doEquals(t,e,r){return!1}toString(t=e.makeContext(null,""),r=0){return t.visited.has(this)?"<...>":(t.visited.add(this),this.doToString(t,r))}doToString(t,e=0){return`${this.constructor.name} does not implement toString()`}}class s extends r{static isTerminal=!0;#s;get value(){return this.#s}constructor(t){super(),this.#s=t}doMatchesEmpty(){return""===this.#s}doStarterList(t,e=[]){return[this]}dominates(t){if((t=t.actualParser())instanceof s){return t.#s.startsWith(this.#s)}}parse(t,r){const s=r+this.#s.length,a=t.input.substring(r,s);return this.#s===a?e.makeSuccess(s,this.#s):e.makeFailure(r)}doEquals(t,e,r){return e instanceof s&&this.#s===e.#s}doToString(t,e=0){const r=this.value.replaceAll("\n","\\n");return this.value.length>1||" "===this.value[0]?`"${r.replaceAll('"','\\"')}"`:r}}class a extends s{static instance=new a;constructor(){super("")}doEquals(t,e,r){return r?e instanceof a:super.doEquals(t,e,!1)}doToString(t,e=0){return"<SUCCESS>"}}class i extends r{#a=!1;get backtracking(){return this.#a}#i;get parsers(){return this.#i}constructor(...t){super(),this.#i=t,1===this.#i.length&&(this.isActualParser=!1)}doMatchesEmpty(){return this.#i.some((t=>t.matchesEmpty()))}doStarterList(t,e=[]){return this.#i.flatMap((r=>r.starterList(t,e))).reduce(((e,r)=>(e.some((e=>e.equals(t,r,!0)))||e.push(r),e)),[])}unwrap(){return[...this.#i]}wrap(...t){const e=new i(...t);return this.#a&&(e.#a=!0),e}asBacktracking(){const t=this.wrap(...this.#i);return t.#a=!0,t}parse(t,r){let s;for(let e=0;e<this.#i.length;++e)if(s=this.#i[e].parse(t,r),s.status)return s;return e.makeFailure(r)}doEquals(t,e,r){if(!(e instanceof i)||this.#i.length!=e.#i.length||this.#a!==e.#a)return!1;for(let s=0;s<this.#i.length;++s)if(!this.#i[s].equals(t,e.#i[s],r))return!1;return!0}doToString(t,e=0){const i=r.indentation.repeat(e),n=r.indentation.repeat(e+1);if(2===this.#i.length&&this.#i[1]instanceof a){let r=this.#i[0].toString(t,e);return this.#i[0]instanceof s||t.visited.has(this.#i[0])||(r="<"+r+">"),r+="?",r}return"ALT<\n"+n+this.#i.map((r=>r.toString(t,e+1))).join("\n"+n+"| ")+"\n"+i+">"}}class n extends r{#n;get parser(){return this.#n}#u;constructor(t,e){super(),this.#n=t,this.#u=e}doMatchesEmpty(){return!1}unwrap(){return[this.#n]}wrap(...t){return new n(t[0],this.#u)}parse(t,r){let s=this.#n.parse(t,r);return s.status?(s=this.#u(s.value,t.input,s.position)?.getParser().parse(t,s.position)??e.makeFailure(s.position),s):s}doEquals(t,e,r){return e instanceof n&&this.#u===e.#u&&this.#n.equals(t,e.parser,r)}doToString(t,e=0){return this.#n.toString(t,e)+" => chained<f()>"}}class u extends r{static isTerminal=!0;static instance=new u;doStarterList(t,e=[]){return[this]}parse(t,r){return e.makeFailure(r)}doEquals(t,e,r){return e instanceof u}doToString(t,e=0){return"<FAILURE>"}}class p extends r{#n;isActualParser=!1;#p;constructor(t){super(),this.#n=t}resolve(){return this.#p||(this.#p=this.#n().getParser()),this.#p}unwrap(){return[this.resolve()]}wrap(...t){const e=this.#n().constructor;return new p((()=>new e(t[0])))}parse(t,e){return this.resolve(),this.#p.parse(t,e)}doEquals(t,e,r){if(e instanceof p){if(this.#n===e.#n)return!0;e=e.resolve()}else if(r)return!1;return this.resolve(),this.#p.equals(t,e,r)}doToString(t,e=0){return this.resolve().toString(t,e)}}class h extends r{#n;get parser(){return this.#n}#h;get type(){return this.#h}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(t,e){super(),this.#n=t,this.#h=e}unwrap(){return[this.#n]}wrap(...t){return new h(t[0],this.#h)}parse(t,r){if(this.#h===h.Type.NEGATIVE_BEHIND||this.#h===h.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#n.parse(t,r).status==(this.#h===h.Type.POSITIVE_AHEAD)?e.makeSuccess(r,""):e.makeFailure(r)}doEquals(t,e,r){return this===e||e instanceof h&&this.#h===e.#h&&this.#n.equals(t,e.#n,r)}doToString(t,e=0){return"("+this.#h+this.#n.toString(t,e)+")"}}class o extends r{#n;get parser(){return this.#n}#o;get mapper(){return this.#o}isActualParser=!1;constructor(t,e){super(),this.#n=t,this.#o=e}unwrap(){return[this.#n]}wrap(...t){return new o(t[0],this.#o)}parse(t,e){const r=this.#n.parse(t,e);return r.status&&(r.value=this.#o(r.value)),r}doEquals(t,e,r){return e instanceof o&&this.#o===e.#o&&this.#n.equals(t,e.#n,r)}doToString(t,e=0){let r=this.#o.toString();return(r.length>80||r.includes("\n"))&&(r="( ... ) => { ... }"),this.#n.toString(t,e)+` -> map<${r}>`}}class c extends r{static isTerminal=!0;#c;get regexp(){return this.#c}#l;#m;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(t,e){super(),t instanceof RegExp?(this.#c=t,this.#l=new RegExp(`^(?:${t.source})`,t.flags)):t instanceof c&&(this.#c=t.#c,this.#l=t.#l,this.regexpGenerated=t.regexpGenerated,this.regexpFullyGenerated=t.regexpFullyGenerated,this.cyclomaticComplexity=t.cyclomaticComplexity),this.#m=e}doStarterList(t,e=[]){return[this]}isFullyGenerated(){return this.regexpFullyGenerated}parse(t,r){const s=this.#l.exec(t.input.substring(r));return s?e.makeSuccess(r+s[0].length,this.#m>=0?s[this.#m]:s):e.makeFailure(r)}doEquals(t,e,r){return e instanceof c&&(!r||this.#m===e.#m)&&this.#c.source===e.#c.source}doToString(t,e=0){return"/"+this.#c.source+"/"}}class l extends r{#i;get parsers(){return this.#i}constructor(...t){super(),this.#i=t,1===this.#i.length&&(this.isActualParser=!1)}doStarterList(t,e=[]){const r=this.#i[0].starterList(t);for(let e=1;e<this.#i.length&&this.#i[e-1].matchesEmpty();++e)this.#i[e].starterList(t).reduce(((e,r)=>(e.some((e=>e.equals(t,r,!1)))||e.push(r),e)),r);return r}doMatchesEmpty(){return this.#i.every((t=>t.matchesEmpty()))}unwrap(){return[...this.#i]}wrap(...t){return new l(...t)}parse(t,r){const s=new Array(this.#i.length),a=e.makeSuccess(r,s);for(let e=0;e<this.#i.length;++e){const r=this.#i[e].parse(t,a.position);if(!r.status)return r;a.value[e]=r.value,a.position=r.position}return a}doEquals(t,e,r){if(!(e instanceof l)||this.#i.length!=e.#i.length)return!1;for(let s=0;s<this.#i.length;++s)if(!this.#i[s].equals(t,e.#i[s],r))return!1;return!0}doToString(t,e=0){const s=r.indentation.repeat(e),a=r.indentation.repeat(e+1);return"SEQ<\n"+this.#i.map((r=>a+r.toString(t,e+1))).join("\n")+"\n"+s+">"}}class m extends r{#a=!1;get backtracking(){return this.#a}#n;get parser(){return this.#n}#g;get min(){return this.#g}#d;get max(){return this.#d}constructor(t,e=0,r=Number.POSITIVE_INFINITY){if(super(),e>r)throw new Error("Min is more than max");this.#n=t,this.#g=e,this.#d=r}doMatchesEmpty(){return 0===this.#g}doStarterList(t,e=[]){const r=this.#n.starterList(t);return this.matchesEmpty()&&!r.some((e=>a.instance.equals(t,e,!1)))&&r.push(a.instance),r}unwrap(){return[this.#n]}wrap(...t){const e=new m(t[0],this.#g,this.#d);return this.#a&&(e.#a=!0),e}asBacktracking(){const t=new m(this.#n,this.#g,this.#d);return t.#a=!0,t}parse(t,r){const s=e.makeSuccess(r,[]);for(let e=0;e<this.#d;++e){const r=this.#n.parse(t,s.position);if(!r.status)return e>=this.#g?s:r;s.value.push(r.value),s.position=r.position}return s}doEquals(t,e,r){return e instanceof m&&this.#a===e.#a&&this.#g===e.#g&&this.#d===e.#d&&this.#n.equals(t,e.#n,r)}doToString(t,e=0){return this.parser.toString(t,e)+(0===this.#g&&1===this.#d?"?":0===this.#g&&this.#d===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#d===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#d?",":this.#d!==Number.POSITIVE_INFINITY?this.#d:"")+"}")}}class g{#n;#x;#w=new Map;Self;static#E=t=>Number(t);static#f=([t,e])=>t;static#S=([t,e])=>e;static#k=([t,e])=>[t,...e];static#v=t=>t instanceof Array?t.join(""):t;static#y=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static#I=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#I.source+String.raw`(?!\.)`)).map(this.#E);static numberNatural=this.regexp(/\d+/).map(this.#E);static numberExponential=this.regexp(new RegExp(this.#I.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#E);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#E);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#y('"')})"`)).map(this.#S);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#y("'")})'`)).map(this.#S);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#y("`")})\``)).map(this.#S);constructor(t,e=!1){this.Self=this.constructor,this.#n=t,this.#x=e}static optimize(t){}static equals(t,r,s=!1){const a=t instanceof g?t.getParser():t,i=r instanceof g?r.getParser():r;return a.equals(e.makeContext(t instanceof g?t:r instanceof g?r:null),i,s)}getParser(){return this.#n}run(t){const r=this.#n.parse(e.makeContext(this,t),0);return r.status&&r.position===t.length?r:e.makeFailure(r.position)}parse(t){const e=this.run(t);if(!e.status)throw new Error("Parsing error");return e.value}static str(t){return new this(new s(t))}static regexp(t,e=0){return new this(new c(t,e))}static regexpGroups(t){return new this(new c(t,-1))}static success(t=void 0){return new this(void 0===t?a.instance:new a)}static failure(){return new this(u.instance)}static seq(...t){return new this(new l(...t.map((t=>t.getParser()))))}static alt(...t){return new this(new i(...t.map((t=>t.getParser()))))}static lookahead(t){return new this(new h(t.getParser(),h.Type.POSITIVE_AHEAD))}static lazy(t){return new this(new p(t))}times(t,e=t){return new this.Self(new m(this.#n,t,e))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(t){return this.times(t,Number.POSITIVE_INFINITY)}atMost(t){return this.times(0,t)}opt(){return this.Self.alt(this,this.Self.success(null))}sepBy(t,e=!1){return this.Self.seq(this,this.Self.seq(t,this).map(g.#S).many()).map(g.#k)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(g.#f)}map(t){return new this.Self(new o(this.#n,t))}chain(t){return new this.Self(new n(this.#n,t))}assert(t){return this.chain(((e,r,s)=>t(e,r,s)?this.Self.success().map((()=>e)):this.Self.failure()))}join(t=""){return this.map(g.#v)}toString(t=0,s=!1){return(s?"\n"+r.indentation.repeat(t):"")+this.#n.toString(e.makeContext(this,""),t)}}export{g as default};
