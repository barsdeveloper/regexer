class e{static indentation="    ";static isActualParser=!0;static mergeResults(e,t){return t?{status:e.status,position:e.position,value:e.value}:e}dominates(e){}unwrap(){return[]}wrap(...e){return null}parse(e,t){return null}actualParser(e=[],t=[]){let r=(!this.constructor.isActualParser||e.find((e=>this instanceof e)))&&!t.find((e=>this instanceof e)),s=r?this.unwrap():void 0;return r&&=1===s?.length,r?s[0].actualParser(e,t):this}withActualParser(e,t=[],r=[]){let s=(!this.constructor.isActualParser||t.some((e=>this instanceof e)))&&!r.some((e=>this instanceof e)),a=s?this.unwrap():void 0;return s&&=1===a?.length,s?this.wrap(a[0].withActualParser(e,t,r)):e}equals(e,t,r){let s=this;if(s===t)return!0;if(r||(s=this.actualParser(),t=t.actualParser()),t instanceof s.constructor&&!(s instanceof t.constructor)||t.resolve&&!s.resolve){const e=s;s=t,t=e}let a=e.visited.get(s,t);return void 0!==a||void 0===a&&(e.visited.set(s,t,!0),a=s.doEquals(e,t,r),e.visited.set(s,t,a)),a}doEquals(e,t,r){return!1}toString(e=0){return`${this.constructor.name} does not implement toString()`}}class t{#e=new Map;get(e,t){return this.#e.get(e)?.get(t)}set(e,t,r){let s=this.#e.get(e);return s||(s=new Map,this.#e.set(e,s)),s.set(t,r),this}setGet(e,t,r){return this.set(e,t,r),r}}class r{static makeSuccess(e,t){return{status:!0,value:t,position:e}}static makeFailure(e){return{status:!1,value:null,position:e}}static makeContext(e,r=""){return{regexer:e,input:r,visited:new t}}}class s extends e{#t=!1;get backtracking(){return this.#t}#r;get parsers(){return this.#r}constructor(...e){super(),this.#r=e}unwrap(){return[...this.#r]}wrap(...e){const t=new s(...e);return this.#t&&(t.#t=!0),t}asBacktracking(){const e=this.wrap(...this.#r);return e.#t=!0,e}parse(e,t){let s;for(let r=0;r<this.#r.length;++r)if(s=this.#r[r].parse(e,t),s.status)return s;return r.makeFailure(t)}doEquals(e,t,r){if(!(t instanceof s)||this.#r.length!=t.#r.length||this.#t!==t.#t)return!1;for(let s=0;s<this.#r.length;++s)if(!this.#r[s].equals(e,t.#r[s],r))return!1;return!0}toString(t=0){const r=e.indentation.repeat(t),s=e.indentation.repeat(t+1);return"ALT<\n"+this.#r.map((e=>s+e.toString(t+1))).join("\n"+s+"|\n")+"\n"+r+">"}}class a extends e{#s;get parser(){return this.#s}#a;constructor(e,t){super(),this.#s=e,this.#a=t}unwrap(){return[this.#s]}wrap(...e){return new a(e[0],this.#a)}parse(e,t){let s=this.#s.parse(e,t);return s.status?(s=this.#a(s.value,e.input,s.position)?.getParser().parse(e,s.position)??r.makeFailure(s.position),s):s}doEquals(e,t,r){return t instanceof a&&this.#a===t.#a&&this.#s.equals(e,t.parser,r)}toString(e=0){return this.#s.toString(e)+" => chained<f()>"}}class i extends e{parse(e,t){return r.makeFailure(t)}doEquals(e,t,r){return t instanceof i}toString(e=0){return"<FAILURE>"}}class n extends e{#s;static isActualParser=!1;#i;constructor(e){super(),this.#s=e}resolve(){return this.#i||(this.#i=this.#s().getParser()),this.#i}unwrap(){return[this.resolve()]}wrap(...e){const t=this.#s().constructor;return new n((()=>new t(e[0])))}parse(e,t){return this.resolve(),this.#i.parse(e,t)}doEquals(e,t,r){if(t instanceof n){if(this.#s===t.#s)return!0;t=t.resolve()}return this.resolve(),this.#i.equals(e,t,r)}toString(e=0){return this.resolve().toString(e)}}class u extends e{#s;get parser(){return this.#s}#n;get type(){return this.#n}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#s=e,this.#n=t}unwrap(){return[this.#s]}wrap(...e){return new u(e[0],this.#n)}parse(e,t){if(this.#n===u.Type.NEGATIVE_BEHIND||this.#n===u.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#s.parse(e,t).status==(this.#n===u.Type.POSITIVE_AHEAD)?r.makeSuccess(t,""):r.makeFailure(t)}doEquals(e,t,r){return this===t||t instanceof u&&this.#n===t.#n&&this.#s.equals(e,t.#s,r)}toString(e=0){return"("+this.#n+this.#s.toString(e)+")"}}class p extends e{static isActualParser=!1;#s;get parser(){return this.#s}#u;get mapper(){return this.#u}constructor(e,t){super(),this.#s=e,this.#u=t}unwrap(){return[this.#s]}wrap(...e){return new p(e[0],this.#u)}parse(e,t){const r=this.#s.parse(e,t);return r.status&&(r.value=this.#u(r.value)),r}doEquals(e,t,r){return t instanceof p&&this.#u===t.#u&&this.#s.equals(e,t.#s,r)}toString(e=0){let t=this.#u.toString();return(t.length>80||t.includes("\n"))&&(t="( ... ) => { ... }"),this.#s.toString(e)+` -> map<${t}>`}}class h extends e{#p;get regexp(){return this.#p}#h;#o;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(e,t){super(),e instanceof RegExp?(this.#p=e,this.#h=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof h&&(this.#p=e.#p,this.#h=e.#h,this.regexpGenerated=e.regexpGenerated,this.regexpFullyGenerated=e.regexpFullyGenerated,this.cyclomaticComplexity=e.cyclomaticComplexity),this.#o=t}isFullyGenerated(){return this.regexpFullyGenerated}parse(e,t){const s=this.#h.exec(e.input.substring(t));return s?r.makeSuccess(t+s[0].length,this.#o>=0?s[this.#o]:s):r.makeFailure(t)}doEquals(e,t,r){return t instanceof h&&(!r||this.#o===t.#o)&&this.#p.source===t.#p.source}toString(e=0){return"/"+this.#p.source+"/"}}class o extends e{#r;get parsers(){return this.#r}constructor(...e){super(),this.#r=e}unwrap(){return[...this.#r]}wrap(...e){return new o(...e)}parse(e,t){const s=new Array(this.#r.length),a=r.makeSuccess(t,s);for(let t=0;t<this.#r.length;++t){const r=this.#r[t].parse(e,a.position);if(!r.status)return r;a.value[t]=r.value,a.position=r.position}return a}doEquals(e,t,r){if(!(t instanceof o)||this.#r.length!=t.#r.length)return!1;for(let s=0;s<this.#r.length;++s)if(!this.#r[s].equals(e,t.#r[s],r))return!1;return!0}toString(t=0){const r=e.indentation.repeat(t),s=e.indentation.repeat(t+1);return"SEQ<\n"+this.#r.map((e=>s+e.toString(t+1))).join("\n")+"\n"+r+">"}}class c extends e{#c;get value(){return this.#c}constructor(e){super(),this.#c=e}dominates(e){if((e=e.actualParser())instanceof c){return e.#c.startsWith(this.#c)}}parse(e,t){const s=t+this.#c.length,a=e.input.substring(t,s);return this.#c===a?r.makeSuccess(s,this.#c):r.makeFailure(t)}doEquals(e,t,r){return t instanceof c&&this.#c===t.#c}toString(e=0){const t=this.value.replaceAll("\n","\\n");return this.value.length>1||" "===this.value[0]?`"${t.replaceAll('"','\\"')}"`:t}}class l extends e{#c;constructor(e){super(),this.#c=e}parse(e,t){return r.makeSuccess(t,this.#c)}doEquals(e,t,r){return t instanceof l}toString(e=0){return"<SUCCESS>"}}class g extends e{#t=!1;get backtracking(){return this.#t}#s;get parser(){return this.#s}#l;get min(){return this.#l}#g;get max(){return this.#g}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is more than max");this.#s=e,this.#l=t,this.#g=r}unwrap(){return[this.#s]}wrap(...e){const t=new g(e[0],this.#l,this.#g);return this.#t&&(t.#t=!0),t}asBacktracking(){const e=new g(this.#s,this.#l,this.#g);return e.#t=!0,e}parse(e,t){const s=r.makeSuccess(t,[]);for(let t=0;t<this.#g;++t){const r=this.#s.parse(e,s.position);if(!r.status)return t>=this.#l?s:r;s.value.push(r.value),s.position=r.position}return s}doEquals(e,t,r){return t instanceof g&&this.#t===t.#t&&this.#l===t.#l&&this.#g===t.#g&&this.#s.equals(e,t.#s,r)}toString(e=0){return this.parser.toString(e)+(0===this.#l&&1===this.#g?"?":0===this.#l&&this.#g===Number.POSITIVE_INFINITY?"*":1===this.#l&&this.#g===Number.POSITIVE_INFINITY?"+":"{"+this.#l+(this.#l!==this.#g?",":this.#g!==Number.POSITIVE_INFINITY?this.#g:"")+"}")}}class m{#s;#m;#d=new Map;Self;static#x=e=>Number(e);static#w=([e,t])=>e;static#f=([e,t])=>t;static#S=([e,t])=>[e,...t];static#E=e=>e instanceof Array?e.join(""):e;static#k=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#v=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#v.source+String.raw`(?!\.)`)).map(this.#x);static numberNatural=this.regexp(/\d+/).map(this.#x);static numberExponential=this.regexp(new RegExp(this.#v.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#x);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#x);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#k('"')})"`)).map(this.#f);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#k("'")})'`)).map(this.#f);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#k("`")})\``)).map(this.#f);constructor(e,t=!1){this.Self=this.constructor,this.#s=e,this.#m=t}static optimize(e){}static equals(e,t,s=!1){const a=e.getParser(),i=t.getParser();return a.equals(r.makeContext(e),i,s)}getParser(){return this.#s}run(e){const t=this.#s.parse(r.makeContext(this,e),0);return t.status&&t.position===e.length?t:r.makeFailure(t.position)}parse(e){const t=this.run(e);if(!t.status)throw new Error("Parsing error");return t.value}static str(e){return new this(new c(e))}static regexp(e,t=0){return new this(new h(e,t))}static regexpGroups(e){return new this(new h(e,-1))}static success(e=void 0){return new this(new l(e))}static failure(){return new this(new i)}static seq(...e){return new this(new o(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new s(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new u(e.getParser(),u.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new n(e))}times(e,t=e){return new this.Self(new g(this.#s,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return this.Self.alt(this,this.Self.success(null))}sepBy(e,t=!1){return this.Self.seq(this,this.Self.seq(e,this).map(m.#f).many()).map(m.#S)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(m.#w)}map(e){return new this.Self(new p(this.#s,e))}chain(e){return new this.Self(new a(this.#s,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?this.Self.success(t):this.Self.failure()))}join(e=""){return this.map(m.#E)}toString(t=0,r=!1){return(r?"\n"+e.indentation.repeat(t):"")+this.#s.toString(t)}}export{m as default};
