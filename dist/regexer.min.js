class e{static indentation="    ";static isActualParser=!0;static mergeResults(e,r){return r?{status:e.status,position:e.position,value:e.value}:e}dominates(e){return this.equals(e,!1)}unwrap(){return null}wrap(e){return null}parse(e,r){return null}actualParser(...e){return!this.constructor.isActualParser||e.find((e=>this instanceof e))?this.unwrap().actualParser():this}withActualParser(e){return this.constructor.isActualParser?e:this.wrap(this.unwrap().withActualParser(e))}equals(e,r){return r?this.actualParser()===e.actualParser():this===e}toString(e){return`${this.constructor.name} does not implement toString()`}}class r{static makeSuccess(e,r){return{status:!0,value:r,position:e}}static makeFailure(e){return{status:!1,value:null,position:e}}static makeContext(e){return{input:e}}}class t extends e{#e;get parsers(){return this.#e}constructor(...e){super(),this.#e=e}parse(e,t){let s;for(let r=0;r<this.#e.length;++r)if(s=this.#e[r].parse(e,t),s.status)return s;return r.makeFailure(t)}equals(e,r){if(r||(e=e.actualParser()),this===e)return!0;if(!(e instanceof t)||this.#e.length!=e.#e.length)return!1;for(let t=0;t<this.#e.length;++t)if(!this.#e[t].equals(e.#e[t],r))return!1;return!0}toString(r=0){const t=e.indentation.repeat(r),s=e.indentation.repeat(r+1);return"ALT<\n"+this.#e.map((e=>s+e.toString(r+1))).join("\n"+s+"|\n")+"\n"+t+">"}}class s extends e{#r;get parser(){return this.#r}#t;constructor(e,r){super(),this.#r=e,this.#t=r}unwrap(){return this.#r}wrap(e){return new s(e,this.#t)}parse(e,t){let s=this.#r.parse(e,t);return s.status?(s=this.#t(s.value,e.input,s.position)?.getParser().parse(e,s.position)??r.makeFailure(s.position),s):s}toString(e=0){return this.#r.toString(e)+" => chained<f()>"}}class a extends e{parse(e,t){return r.makeFailure(t)}equals(e,r){return r||(e=e.actualParser()),e instanceof a}toString(e=0){return"<FAILURE>"}}class n extends e{#r;static isActualParser=!1;#s;constructor(e){super(),this.#r=e}resolve(){return this.#s||(this.#s=this.#r().getParser()),this.#s}unwrap(){return this.resolve()}wrap(e){const r=this.#r().constructor;return new n((()=>new r(e)))}parse(e,r){return this.resolve(),this.#s.parse(e,r)}equals(e,r){return e instanceof n&&this.#r===e.#r||(this.resolve(),r?e instanceof n&&(e=e.resolve()):e=e.actualParser(),this.#s===e||this.#s.equals(e,r))}toString(e=0){return this.resolve().toString(e)}}class i extends e{#r;get parser(){return this.#r}#a;get type(){return this.#a}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,r){super(),this.#r=e,this.#a=r}parse(e,t){if(this.#a===i.Type.NEGATIVE_BEHIND||this.#a===i.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#r.parse(e,t).status==(this.#a===i.Type.POSITIVE_AHEAD)?r.makeSuccess(t,""):r.makeFailure(t)}equals(e,r){return r||(e=e.actualParser()),this===e||e instanceof i&&this.#a===e.#a&&this.#r.equals(e.#r,r)}toString(e=0){return"("+this.#a+this.#r.toString(e)+")"}}class u extends e{static isActualParser=!1;#r;get parser(){return this.#r}#n;get mapper(){return this.#n}constructor(e,r){super(),this.#r=e,this.#n=r}unwrap(){return this.#r}wrap(e){return new u(e,this.#n)}parse(e,r){const t=this.#r.parse(e,r);return t.status&&(t.value=this.#n(t.value)),t}equals(e,r){return r||(e=e.actualParser()),this===e||(r?e instanceof u&&this.#n===e.#n&&this.#r.equals(e.#r,r):this.actualParser().equals(e,r))}toString(e=0){let r=this.#n.toString();return(r.length>80||r.includes("\n"))&&(r="( ... ) => { ... }"),this.#r.toString(e)+` -> map<${r}>`}}class p extends e{#i;get regexp(){return this.#i}#u;#p;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(e,r){super(),e instanceof RegExp?(this.#i=e,this.#u=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof p&&(this.#i=e.#i,this.#u=e.#u,this.regexpGenerated=e.regexpGenerated,this.regexpFullyGenerated=e.regexpFullyGenerated,this.cyclomaticComplexity=e.cyclomaticComplexity),this.#p=r}isFullyGenerated(){return this.regexpFullyGenerated}parse(e,t){const s=this.#u.exec(e.input.substring(t));return s?r.makeSuccess(t+s[0].length,this.#p>=0?s[this.#p]:s):r.makeFailure(t)}equals(e,r){return r||(e=e.actualParser()),e instanceof p&&this.#i.source===e.#i.source}}class o extends e{#e;get parsers(){return this.#e}constructor(...e){super(),this.#e=e}parse(e,t){const s=new Array(this.#e.length),a=r.makeSuccess(t,s);for(let r=0;r<this.#e.length;++r){const t=this.#e[r].parse(e,a.position);if(!t.status)return t;a.value[r]=t.value,a.position=t.position}return a}equals(e,r){if(r||(e=e.actualParser()),this===e)return!0;if(!(e instanceof o)||this.#e.length!=e.#e.length)return!1;for(let t=0;t<this.#e.length;++t)if(!this.#e[t].equals(e.#e[t],r))return!1;return!0}toString(r=0){const t=e.indentation.repeat(r),s=e.indentation.repeat(r+1);return"SEQ<\n"+this.#e.map((e=>s+e.toString(r+1))).join("\n")+"\n"+t+">"}}class c extends e{#o;get value(){return this.#o}constructor(e){super(),this.#o=e}dominates(e){if((e=e.actualParser())instanceof c){return e.#o.startsWith(this.#o)}}parse(e,t){const s=t+this.#o.length,a=e.input.substring(t,s);return this.#o===a?r.makeSuccess(s,this.#o):r.makeFailure(t)}equals(e,r){return r||(e=e.actualParser()),e instanceof c&&this.#o===e.#o}toString(e=0){const r=this.value.replaceAll("\n","\\n");return this.value.length>1||" "===this.value[0]?`"${r.replaceAll('"','\\"')}"`:r}}class l extends e{#o;constructor(e){super(),this.#o=e}parse(e,t){return r.makeSuccess(t,this.#o)}equals(e,r){return r||(e=e.actualParser()),e instanceof l}toString(e=0){return"<SUCCESS>"}}class h extends e{#r;get parser(){return this.#r}#c;get min(){return this.#c}#l;get max(){return this.#l}constructor(e,r=0,t=Number.POSITIVE_INFINITY){if(super(),r>t)throw new Error("Min is more than max");this.#r=e,this.#c=r,this.#l=t}unwrap(){return this.#r}wrap(e){return new h(e,this.#c,this.#l)}parse(e,t){const s=r.makeSuccess(t,[]);for(let r=0;r<this.#l;++r){const t=this.#r.parse(e,s.position);if(!t.status)return r>=this.#c?s:t;s.value.push(t.value),s.position=t.position}return s}equals(e,r){return r||(e=e.actualParser()),this===e||e instanceof h&&this.#c===e.#c&&this.#l===e.#l&&this.#r.equals(e.#r,r)}toString(e=0){return this.parser.toString(e)+(0===this.#c&&1===this.#l?"?":0===this.#c&&this.#l===Number.POSITIVE_INFINITY?"*":1===this.#c&&this.#l===Number.POSITIVE_INFINITY?"+":"{"+this.#c+(this.#c!==this.#l?",":this.#l!==Number.POSITIVE_INFINITY?this.#l:"")+"}")}}class m{#r;#h;#m=new Map;static#g=e=>Number(e);static#x=([e,r])=>e;static#d=([e,r])=>r;static#w=([e,r])=>[e,...r];static#f=e=>e instanceof Array?e.join(""):e;static#S=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#E=/[-\+]?(?:\d*\.)?\d+/;static number=m.regexp(new RegExp(m.#E.source+String.raw`(?!\.)`)).map(m.#g);static numberNatural=m.regexp(/\d+/).map(m.#g);static numberExponential=m.regexp(new RegExp(m.#E.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(m.#g);static numberUnit=m.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(m.#g);static whitespace=m.regexp(/\s+/);static whitespaceInline=m.regexp(/[^\S\n]+/);static whitespaceMultiline=m.regexp(/\s*?\n\s*/);static optWhitespace=m.regexp(/\s*/);static doubleQuotedString=m.regexpGroups(new RegExp(`"(${m.#S('"')})"`)).map(m.#d);static singleQuotedString=m.regexpGroups(new RegExp(`'(${m.#S("'")})'`)).map(m.#d);static backtickQuotedString=m.regexpGroups(new RegExp(`\`(${m.#S("`")})\``)).map(m.#d);constructor(e,r=!1){this.#r=e,this.#h=r}static optimize(e){}static equals(e,r,t=!1){const s=e.getParser(),a=r.getParser();return a instanceof s.constructor&&!(s instanceof a.constructor)?a.equals(s,t):s.equals(a,t)}getParser(){return this.#r}run(e){const t=this.#r.parse(r.makeContext(e),0);return t.status&&t.position===e.length?t:r.makeFailure(t.position)}parse(e){const r=this.run(e);if(!r.status)throw new Error("Parsing error");return r.value}static str(e){return new m(new c(e))}static regexp(e,r=0){return new m(new p(e,r))}static regexpGroups(e){return new m(new p(e,-1))}static success(e=void 0){return new m(new l(e))}static failure(){return new m(new a)}static seq(...e){return new m(new o(...e.map((e=>e.getParser()))))}static alt(...e){return new m(new t(...e.map((e=>e.getParser()))))}static lookahead(e){return new m(new i(e.getParser(),i.Type.POSITIVE_AHEAD))}static lazy(e){return new m(new n(e))}times(e,r=e){return new m(new h(this.#r,e,r))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return m.alt(this,m.success(void 0))}sepBy(e,r=!1){return m.seq(this,m.seq(e,this).map(m.#d).many()).map(m.#w)}skipSpace(){return m.seq(this,m.optWhitespace).map(m.#x)}map(e){return new m(new u(this.#r,e))}chain(e){return new m(new s(this.#r,e))}assert(e){return this.chain(((r,t,s)=>e(r,t,s)?m.success(r):m.failure()))}join(e=""){return this.map(m.#f)}toString(r=0,t=!1){return(t?"\n"+e.indentation.repeat(r):"")+this.#r.toString(r)}}export{m as default};
