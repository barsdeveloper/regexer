import Parser from "./Parser.js"
import Reply from "../Reply.js"

/**
 * @template {Number} Group
 * @extends {Parser<Group extends -1 ? RegExpExecArray : String>}
 */
export default class RegExpParser extends Parser {

    static isTerminal = true

    /** @type {RegExp} */
    #regexp
    get regexp() {
        return this.#regexp
    }
    /** @type {RegExp} */
    #anchoredRegexp
    #group

    regexpGenerated = false // This regexp was generated by the optimizer to replace other parsers
    regexpFullyGenerated = true // This regexp is fully generated (does not have any user provided regexp in its tree)
    cyclomaticComplexity = 1


    /**
     * @param {RegExp | RegExpParser} regexp
     * @param {Group} group
     */
    constructor(regexp, group) {
        super()
        if (regexp instanceof RegExp) {
            this.#regexp = regexp
            this.#anchoredRegexp = new RegExp(`^(?:${regexp.source})`, regexp.flags)
        } else if (regexp instanceof RegExpParser) {
            this.#regexp = regexp.#regexp
            this.#anchoredRegexp = regexp.#anchoredRegexp
            this.regexpGenerated = regexp.regexpGenerated
            this.regexpFullyGenerated = regexp.regexpFullyGenerated
            this.cyclomaticComplexity = regexp.cyclomaticComplexity
        }
        this.#group = group
    }

    /**
     * @protected
     * @param {Parser<any>[]} additional
     * @param {Context} context
     */
    doTerminalList(type, additional, context) {
        return [this]
    }

    isFullyGenerated() {
        return this.regexpFullyGenerated
    }

    /**
     * @param {Context} context
     * @param {Number} position
     */
    parse(context, position) {
        const match = this.#anchoredRegexp.exec(context.input.substring(position))
        return match
            ? Reply.makeSuccess(position + match[0].length, this.#group >= 0 ? match[this.#group] : match)
            : Reply.makeFailure(position)
    }

    /**
     * @protected
     * @param {Context} context
     * @param {Parser<any>} other
     * @param {Boolean} strict
     */
    doEquals(context, other, strict) {
        return other instanceof RegExpParser
            && (!strict || this.#group === other.#group)
            && this.#regexp.source === other.#regexp.source
    }

    /**
     * @protected
     * @param {Context} context
     */
    doToString(context, indent = 0) {
        return "/" + this.#regexp.source + "/"
    }
}
