class t{#t=new Map;get(t,e){return this.#t.get(t)?.get(e)}set(t,e,s){let r=this.#t.get(t);return r||(r=new Map,this.#t.set(t,r)),r.set(e,s),this}setGet(t,e,s){return this.set(t,e,s),s}}class e{static makeSuccess(t,e){return{status:!0,value:e,position:t}}static makeFailure(t){return{status:!1,value:null,position:t}}static makeContext(e,s=""){return{regexer:e,input:s,equals:new t,visited:new Set}}}class s{static TerminalType={STARTING:-1,ONLY:0,ENDING:1};static isTerminal=!1;static indentation="    ";#e;#s={};isActualParser=!0;static mergeResults(t,e){return e?{status:t.status,position:t.position,value:t.value}:t}matchesEmpty(){return void 0===this.#e?this.#e=this.doMatchesEmpty():this.#e}doMatchesEmpty(){const t=this.unwrap();return 1===t.length&&t[0].doMatchesEmpty()}terminalList(t,s=e.makeContext(null,""),r=[]){if(!this.#s[t]){if(s.visited.has(this))return[];s.visited.add(this),this.#s[t]=this.doTerminalList(t,s,r),r.length&&(this.#s[t]=this.#s[t].filter((t=>!t.constructor.isTerminal&&r.includes(t))))}let a=this.#s[t];return!this.constructor.isTerminal&&r.includes(this)&&(a=[this,...a]),a}doTerminalList(t,e,s=[]){let r=this.unwrap();return 1===r?.length?r[0].terminalList(t,e,s):[]}dominates(t){}unwrap(){return[]}wrap(...t){return null}parse(t,e){return null}actualParser(t=[],e=[]){let s=(!this.isActualParser||t.find((t=>this instanceof t)))&&!e.find((t=>this instanceof t)),r=s?this.unwrap():void 0;return s&&=1===r?.length,s?r[0].actualParser(t,e):this}withActualParser(t,e=[],s=[]){let r=(!this.isActualParser||e.some((t=>this instanceof t)))&&!s.some((t=>this instanceof t)),a=r?this.unwrap():void 0;return r&&=1===a?.length,r?this.wrap(a[0].withActualParser(t,e,s)):t}equals(t,e,s){let r=this;if(r===e)return!0;if(s||(r=this.actualParser(),e=e.actualParser()),e instanceof r.constructor&&!(r instanceof e.constructor)||e.resolve&&!r.resolve){const t=r;r=e,e=t}let a=t.equals.get(r,e);return void 0!==a||void 0===a&&(t.equals.set(r,e,!0),a=r.doEquals(t,e,s),t.equals.set(r,e,a)),a}doEquals(t,e,s){return!1}toString(t=e.makeContext(null,""),s=0){return t.visited.has(this)?"<...>":(t.visited.add(this),this.doToString(t,s))}doToString(t,e=0){return`${this.constructor.name} does not implement toString()`}}class r extends s{static isTerminal=!0;static successParserInstance;#r;get value(){return this.#r}constructor(t){super(),this.#r=t}doMatchesEmpty(){return""===this.#r}doTerminalList(t,e,s=[]){return""===this.value?[r.successParserInstance]:[this]}dominates(t){if((t=t.actualParser())instanceof r){return t.#r.startsWith(this.#r)}}parse(t,s){const r=s+this.#r.length,a=t.input.substring(s,r);return this.#r===a?e.makeSuccess(r,this.#r):e.makeFailure(s)}doEquals(t,e,s){return e instanceof r&&this.#r===e.#r}doToString(t,e=0){const s=this.value.replaceAll("\n","\\n");return 1!==this.value.length||this.value.trim()!==this.value?`"${s.replaceAll('"','\\"')}"`:s}}class a extends r{static instance=new a;static{r.successParserInstance=this.instance}constructor(){super("")}doEquals(t,e,s){return s?e instanceof a:super.doEquals(t,e,!1)}doToString(t,e=0){return"<SUCCESS>"}}class i extends s{#a=!1;get backtracking(){return this.#a}#i;get parsers(){return this.#i}constructor(...t){super(),this.#i=t,1===this.#i.length&&(this.isActualParser=!1)}doMatchesEmpty(){return this.#i.some((t=>t.matchesEmpty()))}doTerminalList(t,e,s=[]){return this.#i.flatMap((s=>s.terminalList(t,e))).reduce(((t,s)=>(t.some((t=>t.equals(e,s,!0)))||t.push(s),t)),[])}unwrap(){return[...this.#i]}wrap(...t){const e=new i(...t);return this.#a&&(e.#a=!0),e}asBacktracking(){const t=this.wrap(...this.#i);return t.#a=!0,t}parse(t,s){let r;for(let e=0;e<this.#i.length;++e)if(r=this.#i[e].parse(t,s),r.status)return r;return e.makeFailure(s)}doEquals(t,e,s){if(!(e instanceof i)||this.#i.length!=e.#i.length||this.#a!==e.#a)return!1;for(let r=0;r<this.#i.length;++r)if(!this.#i[r].equals(t,e.#i[r],s))return!1;return!0}doToString(t,e=0){const i=s.indentation.repeat(e),n=s.indentation.repeat(e+1);if(2===this.#i.length&&this.#i[1]instanceof a){let s=this.#i[0].toString(t,e);return this.#i[0]instanceof r||t.visited.has(this.#i[0])||(s="<"+s+">"),s+="?",s}return"ALT<\n"+n+this.#i.map((s=>s.toString(t,e+1))).join("\n"+n+"| ")+"\n"+i+">"}}class n extends s{#n;get parser(){return this.#n}#u;constructor(t,e){super(),this.#n=t,this.#u=e}doMatchesEmpty(){return!1}unwrap(){return[this.#n]}wrap(...t){return new n(t[0],this.#u)}parse(t,s){let r=this.#n.parse(t,s);return r.status?(r=this.#u(r.value,t.input,r.position)?.getParser().parse(t,r.position)??e.makeFailure(r.position),r):r}doEquals(t,e,s){return e instanceof n&&this.#u===e.#u&&this.#n.equals(t,e.parser,s)}doToString(t,e=0){return this.#n.toString(t,e)+" => chained<f()>"}}class u extends s{static isTerminal=!0;static instance=new u;doTerminalList(t,e=[]){return[this]}parse(t,s){return e.makeFailure(s)}doEquals(t,e,s){return e instanceof u}doToString(t,e=0){return"<FAILURE>"}}class p extends s{#n;isActualParser=!1;#p;constructor(t){super(),this.#n=t}resolve(){return this.#p||(this.#p=this.#n().getParser()),this.#p}unwrap(){return[this.resolve()]}wrap(...t){const e=this.#n().constructor;return new p((()=>new e(t[0])))}parse(t,e){return this.resolve(),this.#p.parse(t,e)}doEquals(t,e,s){if(e instanceof p){if(this.#n===e.#n)return!0;e=e.resolve()}else if(s)return!1;return this.resolve(),this.#p.equals(t,e,s)}doToString(t,e=0){return this.resolve().toString(t,e)}}class h extends s{#n;get parser(){return this.#n}#h;get type(){return this.#h}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(t,e){super(),this.#n=t,this.#h=e}doTerminalList(t,e,s=[]){return[]}unwrap(){return[this.#n]}wrap(...t){return new h(t[0],this.#h)}parse(t,s){if(this.#h===h.Type.NEGATIVE_BEHIND||this.#h===h.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#n.parse(t,s).status==(this.#h===h.Type.POSITIVE_AHEAD)?e.makeSuccess(s,""):e.makeFailure(s)}doEquals(t,e,s){return this===e||e instanceof h&&this.#h===e.#h&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){return"("+this.#h+this.#n.toString(t,e)+")"}}class c extends s{#n;get parser(){return this.#n}#c;get mapper(){return this.#c}isActualParser=!1;constructor(t,e){super(),this.#n=t,this.#c=e}unwrap(){return[this.#n]}wrap(...t){return new c(t[0],this.#c)}parse(t,e){const s=this.#n.parse(t,e);return s.status&&(s.value=this.#c(s.value)),s}doEquals(t,e,s){return e instanceof c&&this.#c===e.#c&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){let s=this.#c.toString();return(s.length>80||s.includes("\n"))&&(s="( ... ) => { ... }"),this.#n.toString(t,e)+` -> map<${s}>`}}class o extends s{static isTerminal=!0;#o;get regexp(){return this.#o}#l;#m;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(t,e){super(),t instanceof RegExp?(this.#o=t,this.#l=new RegExp(`^(?:${t.source})`,t.flags)):t instanceof o&&(this.#o=t.#o,this.#l=t.#l,this.regexpGenerated=t.regexpGenerated,this.regexpFullyGenerated=t.regexpFullyGenerated,this.cyclomaticComplexity=t.cyclomaticComplexity),this.#m=e}doTerminalList(t,e,s=[]){return[this]}isFullyGenerated(){return this.regexpFullyGenerated}parse(t,s){const r=this.#l.exec(t.input.substring(s));return r?e.makeSuccess(s+r[0].length,this.#m>=0?r[this.#m]:r):e.makeFailure(s)}doEquals(t,e,s){return e instanceof o&&(!s||this.#m===e.#m)&&this.#o.source===e.#o.source}doToString(t,e=0){return"/"+this.#o.source+"/"}}class l extends s{#i;get parsers(){return this.#i}constructor(...t){super(),this.#i=t,1===this.#i.length&&(this.isActualParser=!1)}doTerminalList(t,e,r=[]){if(0===t){for(let s=0;s<this.#i.length;++s)if(!this.#i[s].matchesEmpty())for(let a=this.#i.length-1;a>=s;--a)if(!this.#i[a].matchesEmpty())return s==a?this.#i[s].terminalList(t,e,r):[];t=s.TerminalType.STARTING}let i=t<0?0:this.#i.length-1;const n=-t,u=this.#i[i].terminalList(t,e);for(i+=n;i>=0&&i<this.#i.length&&this.#i[i-n].matchesEmpty();i+=n)this.#i[i].terminalList(t,e).reduce(((t,s)=>(t.some((t=>t.equals(e,s,!1)))||t.push(s),t)),u);if(!this.#i[i-n].matchesEmpty()){const t=u.indexOf(a.instance);t>=0&&u.splice(t,1)}return u}doMatchesEmpty(){return this.#i.every((t=>t.matchesEmpty()))}unwrap(){return[...this.#i]}wrap(...t){return new l(...t)}parse(t,s){const r=new Array(this.#i.length),a=e.makeSuccess(s,r);for(let e=0;e<this.#i.length;++e){const s=this.#i[e].parse(t,a.position);if(!s.status)return s;a.value[e]=s.value,a.position=s.position}return a}doEquals(t,e,s){if(!(e instanceof l)||this.#i.length!=e.#i.length)return!1;for(let r=0;r<this.#i.length;++r)if(!this.#i[r].equals(t,e.#i[r],s))return!1;return!0}doToString(t,e=0){const r=s.indentation.repeat(e),a=s.indentation.repeat(e+1);return"SEQ<\n"+this.#i.map((s=>a+s.toString(t,e+1))).join("\n")+"\n"+r+">"}}class m extends s{#a=!1;get backtracking(){return this.#a}#n;get parser(){return this.#n}#g;get min(){return this.#g}#d;get max(){return this.#d}constructor(t,e=0,s=Number.POSITIVE_INFINITY){if(super(),e>s)throw new Error("Min is greater than max");this.#n=t,this.#g=e,this.#d=s}doMatchesEmpty(){return 0===this.#g}doTerminalList(t,e,s=[]){const r=this.#n.terminalList(t,e);return this.matchesEmpty()&&!r.some((t=>a.instance.equals(e,t,!1)))&&r.push(a.instance),r}unwrap(){return[this.#n]}wrap(...t){const e=new m(t[0],this.#g,this.#d);return this.#a&&(e.#a=!0),e}asBacktracking(){const t=new m(this.#n,this.#g,this.#d);return t.#a=!0,t}parse(t,s){const r=e.makeSuccess(s,[]);for(let e=0;e<this.#d;++e){const s=this.#n.parse(t,r.position);if(!s.status)return e>=this.#g?r:s;r.value.push(s.value),r.position=s.position}return r}doEquals(t,e,s){return e instanceof m&&this.#a===e.#a&&this.#g===e.#g&&this.#d===e.#d&&this.#n.equals(t,e.#n,s)}doToString(t,e=0){return this.parser.toString(t,e)+(0===this.#g&&1===this.#d?"?":0===this.#g&&this.#d===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#d===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#d?",":this.#d!==Number.POSITIVE_INFINITY?this.#d:"")+"}")}}class g{#n;#f;#E=new Map;Self;static#x=t=>Number(t);static#w=([t,e])=>t;static#S=([t,e])=>e;static#T=([t,e])=>[t,...e];static#k=t=>t instanceof Array?t.join(""):t;static#y=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static#v=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#v.source+String.raw`(?!\.)`)).map(this.#x);static numberNatural=this.regexp(/\d+/).map(this.#x);static numberExponential=this.regexp(new RegExp(this.#v.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#x);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#x);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#y('"')})"`)).map(this.#S);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#y("'")})'`)).map(this.#S);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#y("`")})\``)).map(this.#S);constructor(t,e=!1){this.Self=this.constructor,this.#n=t,this.#f=e}static optimize(t){}static equals(t,s,r=!1){const a=t instanceof g?t.getParser():t,i=s instanceof g?s.getParser():s;return a.equals(e.makeContext(t instanceof g?t:s instanceof g?s:null),i,r)}getParser(){return this.#n}run(t){const s=this.#n.parse(e.makeContext(this,t),0);return s.status&&s.position===t.length?s:e.makeFailure(s.position)}parse(t){const e=this.run(t);if(!e.status)throw new Error("Parsing error");return e.value}static str(t){return new this(new r(t))}static regexp(t,e=0){return new this(new o(t,e))}static regexpGroups(t){return new this(new o(t,-1))}static success(){return new this(a.instance)}static failure(){return new this(u.instance)}static seq(...t){return new this(new l(...t.map((t=>t.getParser()))))}static alt(...t){return new this(new i(...t.map((t=>t.getParser()))))}static lookahead(t){return new this(new h(t.getParser(),h.Type.POSITIVE_AHEAD))}static lazy(t){return new this(new p(t))}times(t,e=t){return new this.Self(new m(this.#n,t,e))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(t){return this.times(t,Number.POSITIVE_INFINITY)}atMost(t){return this.times(0,t)}opt(){return this.Self.alt(this,this.Self.success())}sepBy(t,e=!1){return this.Self.seq(this,this.Self.seq(t,this).map(g.#S).many()).map(g.#T)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(g.#w)}map(t){return new this.Self(new c(this.#n,t))}chain(t){return new this.Self(new n(this.#n,t))}assert(t){return this.chain(((e,s,r)=>t(e,s,r)?this.Self.success().map((()=>e)):this.Self.failure()))}join(t=""){return this.map(g.#k)}toString(t=0,r=!1){return(r?"\n"+s.indentation.repeat(t):"")+this.#n.toString(e.makeContext(this,""),t)}}export{g as default};
