class e{static indentation="    ";static isActualParser=!0;static mergeResults(e,r){return r?{status:e.status,position:e.position,value:e.value}:e}dominates(e){}unwrap(){return[]}wrap(...e){return null}parse(e,r){return null}actualParser(e=[],r=[]){let t=(!this.constructor.isActualParser||e.find((e=>this instanceof e)))&&!r.find((e=>this instanceof e)),s=t?this.unwrap():void 0;return t&&=1===s?.length,t?s[0].actualParser(e,r):this}withActualParser(e,r=[],t=[]){let s=(!this.constructor.isActualParser||r.some((e=>this instanceof e)))&&!t.some((e=>this instanceof e)),a=s?this.unwrap():void 0;return s&&=1===a?.length,s?this.wrap(a[0].withActualParser(e,r,t)):e}equals(e,r,t){let s=this;if(s===r)return!0;t||(s=this.actualParser(),r=r.actualParser());let a=e.visited.get(s,r);return void 0!==a||void 0===a&&(e.visited.set(s,r,!0),a=s.doEquals(e,r,t),e.visited.set(s,r,a)),a}doEquals(e,r,t){return!1}toString(e=0){return`${this.constructor.name} does not implement toString()`}}class r{#e=new Map;get(e,r){return this.#e.get(e)?.get(r)}set(e,r,t){let s=this.#e.get(e);return s||(s=new Map,this.#e.set(e,s)),s.set(r,t),this}setGet(e,r,t){return this.set(e,r,t),t}}class t{static makeSuccess(e,r){return{status:!0,value:r,position:e}}static makeFailure(e){return{status:!1,value:null,position:e}}static makeContext(e,t=""){return{regexer:e,input:t,visited:new r}}}class s extends e{#r;get parsers(){return this.#r}constructor(...e){super(),this.#r=e}unwrap(){return[...this.#r]}wrap(...e){return new s(...e)}parse(e,r){let s;for(let t=0;t<this.#r.length;++t)if(s=this.#r[t].parse(e,r),s.status)return s;return t.makeFailure(r)}doEquals(e,r,t){if(!(r instanceof s)||this.#r.length!=r.#r.length)return!1;for(let s=0;s<this.#r.length;++s)if(!this.#r[s].equals(e,r.#r[s],t))return!1;return!0}toString(r=0){const t=e.indentation.repeat(r),s=e.indentation.repeat(r+1);return"ALT<\n"+this.#r.map((e=>s+e.toString(r+1))).join("\n"+s+"|\n")+"\n"+t+">"}}class a extends e{#t;get parser(){return this.#t}#s;constructor(e,r){super(),this.#t=e,this.#s=r}unwrap(){return[this.#t]}wrap(...e){return new a(e[0],this.#s)}parse(e,r){let s=this.#t.parse(e,r);return s.status?(s=this.#s(s.value,e.input,s.position)?.getParser().parse(e,s.position)??t.makeFailure(s.position),s):s}doEquals(e,r,t){return r instanceof a&&this.#s===r.#s&&this.#t.equals(e,r.parser,t)}toString(e=0){return this.#t.toString(e)+" => chained<f()>"}}class n extends e{parse(e,r){return t.makeFailure(r)}doEquals(e,r,t){return r instanceof n}toString(e=0){return"<FAILURE>"}}class i extends e{#t;static isActualParser=!1;#a;constructor(e){super(),this.#t=e}resolve(){return this.#a||(this.#a=this.#t().getParser()),this.#a}unwrap(){return[this.resolve()]}wrap(...e){const r=this.#t().constructor;return new i((()=>new r(e[0])))}parse(e,r){return this.resolve(),this.#a.parse(e,r)}doEquals(e,r,t){if(r instanceof i){if(this.#t===r.#t)return!0;r=r.resolve()}return this.resolve(),this.#a.equals(e,r,t)}toString(e=0){return this.resolve().toString(e)}}class u extends e{#t;get parser(){return this.#t}#n;get type(){return this.#n}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,r){super(),this.#t=e,this.#n=r}unwrap(){return[this.#t]}wrap(...e){return new u(e[0],this.#n)}parse(e,r){if(this.#n===u.Type.NEGATIVE_BEHIND||this.#n===u.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#t.parse(e,r).status==(this.#n===u.Type.POSITIVE_AHEAD)?t.makeSuccess(r,""):t.makeFailure(r)}doEquals(e,r,t){return this===r||r instanceof u&&this.#n===r.#n&&this.#t.equals(e,r.#t,t)}toString(e=0){return"("+this.#n+this.#t.toString(e)+")"}}class p extends e{static isActualParser=!1;#t;get parser(){return this.#t}#i;get mapper(){return this.#i}constructor(e,r){super(),this.#t=e,this.#i=r}unwrap(){return[this.#t]}wrap(...e){return new p(e[0],this.#i)}parse(e,r){const t=this.#t.parse(e,r);return t.status&&(t.value=this.#i(t.value)),t}doEquals(e,r,t){return r instanceof p&&this.#i===r.#i&&this.#t.equals(e,r.#t,t)}toString(e=0){let r=this.#i.toString();return(r.length>80||r.includes("\n"))&&(r="( ... ) => { ... }"),this.#t.toString(e)+` -> map<${r}>`}}class o extends e{#u;get regexp(){return this.#u}#p;#o;regexpGenerated=!1;regexpFullyGenerated=!0;cyclomaticComplexity=1;constructor(e,r){super(),e instanceof RegExp?(this.#u=e,this.#p=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof o&&(this.#u=e.#u,this.#p=e.#p,this.regexpGenerated=e.regexpGenerated,this.regexpFullyGenerated=e.regexpFullyGenerated,this.cyclomaticComplexity=e.cyclomaticComplexity),this.#o=r}isFullyGenerated(){return this.regexpFullyGenerated}parse(e,r){const s=this.#p.exec(e.input.substring(r));return s?t.makeSuccess(r+s[0].length,this.#o>=0?s[this.#o]:s):t.makeFailure(r)}doEquals(e,r,t){return r instanceof o&&(!t||this.#o===r.#o)&&this.#u.source===r.#u.source}toString(e=0){return"/"+this.#u.source+"/"}}class c extends e{#r;get parsers(){return this.#r}constructor(...e){super(),this.#r=e}unwrap(){return[...this.#r]}wrap(...e){return new c(...e)}parse(e,r){const s=new Array(this.#r.length),a=t.makeSuccess(r,s);for(let r=0;r<this.#r.length;++r){const t=this.#r[r].parse(e,a.position);if(!t.status)return t;a.value[r]=t.value,a.position=t.position}return a}doEquals(e,r,t){if(!(r instanceof c)||this.#r.length!=r.#r.length)return!1;for(let s=0;s<this.#r.length;++s)if(!this.#r[s].equals(e,r.#r[s],t))return!1;return!0}toString(r=0){const t=e.indentation.repeat(r),s=e.indentation.repeat(r+1);return"SEQ<\n"+this.#r.map((e=>s+e.toString(r+1))).join("\n")+"\n"+t+">"}}class h extends e{#c;get value(){return this.#c}constructor(e){super(),this.#c=e}dominates(e){if((e=e.actualParser())instanceof h){return e.#c.startsWith(this.#c)}}parse(e,r){const s=r+this.#c.length,a=e.input.substring(r,s);return this.#c===a?t.makeSuccess(s,this.#c):t.makeFailure(r)}doEquals(e,r,t){return r instanceof h&&this.#c===r.#c}toString(e=0){const r=this.value.replaceAll("\n","\\n");return this.value.length>1||" "===this.value[0]?`"${r.replaceAll('"','\\"')}"`:r}}class l extends e{#c;constructor(e){super(),this.#c=e}parse(e,r){return t.makeSuccess(r,this.#c)}doEquals(e,r,t){return r instanceof l}toString(e=0){return"<SUCCESS>"}}class m extends e{#t;get parser(){return this.#t}#h;get min(){return this.#h}#l;get max(){return this.#l}constructor(e,r=0,t=Number.POSITIVE_INFINITY){if(super(),r>t)throw new Error("Min is more than max");this.#t=e,this.#h=r,this.#l=t}unwrap(){return[this.#t]}wrap(...e){return new m(e[0],this.#h,this.#l)}parse(e,r){const s=t.makeSuccess(r,[]);for(let r=0;r<this.#l;++r){const t=this.#t.parse(e,s.position);if(!t.status)return r>=this.#h?s:t;s.value.push(t.value),s.position=t.position}return s}doEquals(e,r,t){return r instanceof m&&this.#h===r.#h&&this.#l===r.#l&&this.#t.equals(e,r.#t,t)}toString(e=0){return this.parser.toString(e)+(0===this.#h&&1===this.#l?"?":0===this.#h&&this.#l===Number.POSITIVE_INFINITY?"*":1===this.#h&&this.#l===Number.POSITIVE_INFINITY?"+":"{"+this.#h+(this.#h!==this.#l?",":this.#l!==Number.POSITIVE_INFINITY?this.#l:"")+"}")}}class g{#t;#m;#g=new Map;static#d=e=>Number(e);static#x=([e,r])=>e;static#w=([e,r])=>r;static#E=([e,r])=>[e,...r];static#f=e=>e instanceof Array?e.join(""):e;static#S=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#v=/[-\+]?(?:\d*\.)?\d+/;static number=g.regexp(new RegExp(g.#v.source+String.raw`(?!\.)`)).map(g.#d);static numberNatural=g.regexp(/\d+/).map(g.#d);static numberExponential=g.regexp(new RegExp(g.#v.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(g.#d);static numberUnit=g.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(g.#d);static whitespace=g.regexp(/\s+/);static whitespaceInline=g.regexp(/[^\S\n]+/);static whitespaceMultiline=g.regexp(/\s*?\n\s*/);static optWhitespace=g.regexp(/\s*/);static doubleQuotedString=g.regexpGroups(new RegExp(`"(${g.#S('"')})"`)).map(g.#w);static singleQuotedString=g.regexpGroups(new RegExp(`'(${g.#S("'")})'`)).map(g.#w);static backtickQuotedString=g.regexpGroups(new RegExp(`\`(${g.#S("`")})\``)).map(g.#w);constructor(e,r=!1){this.#t=e,this.#m=r}static optimize(e){}static equals(e,r,s=!1){const a=e.getParser(),n=r.getParser();return n instanceof a.constructor&&!(a instanceof n.constructor)?n.equals(t.makeContext(r),a,s):a.equals(t.makeContext(e),n,s)}getParser(){return this.#t}run(e){const r=this.#t.parse(t.makeContext(this,e),0);return r.status&&r.position===e.length?r:t.makeFailure(r.position)}parse(e){const r=this.run(e);if(!r.status)throw new Error("Parsing error");return r.value}static str(e){return new g(new h(e))}static regexp(e,r=0){return new g(new o(e,r))}static regexpGroups(e){return new g(new o(e,-1))}static success(e=void 0){return new g(new l(e))}static failure(){return new g(new n)}static seq(...e){return new g(new c(...e.map((e=>e.getParser()))))}static alt(...e){return new g(new s(...e.map((e=>e.getParser()))))}static lookahead(e){return new g(new u(e.getParser(),u.Type.POSITIVE_AHEAD))}static lazy(e){return new g(new i(e))}times(e,r=e){return new g(new m(this.#t,e,r))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return g.alt(this,g.success(null))}sepBy(e,r=!1){return g.seq(this,g.seq(e,this).map(g.#w).many()).map(g.#E)}skipSpace(){return g.seq(this,g.optWhitespace).map(g.#x)}map(e){return new g(new p(this.#t,e))}chain(e){return new g(new a(this.#t,e))}assert(e){return this.chain(((r,t,s)=>e(r,t,s)?g.success(r):g.failure()))}join(e=""){return this.map(g.#f)}toString(r=0,t=!1){return(t?"\n"+e.indentation.repeat(r):"")+this.#t.toString(r)}}export{g as default};
